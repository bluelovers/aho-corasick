// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";

  var AhoCorasick, Trie;

  Trie = (function() {

    function Trie() {
      this.next = {};
      this.is_word = null;
      this.value = null;
      this.data = [];
    }

    Trie.prototype.add = function(word, data, original_word) {
      var chr, node;
      chr = word.charAt(0);
      node = this.next[chr];
      if (!node) {
        node = this.next[chr] = new Trie();
        if (original_word) {
          node.value = original_word.substr(0, original_word.length - word.length + 1);
        } else {
          node.value = chr;
        }
      }
      if (word.length > 1) {
        return node.add(word.substring(1), data, original_word || word);
      } else {
        node.data.push(data);
        return node.is_word = true;
      }
    };

    Trie.prototype.find = function(word) {
      var next;
      if (word.length === 0 || this.is_word) {
        return this;
      }
      next = this.next[word.charAt(0)];
      if (next) {
        return next.find(word.substring(1));
      } else {
        return null;
      }
    };

    Trie.prototype.explore_fail_link = function(word) {
      var chr, i, node, _i, _ref;
      node = this;
      for (i = _i = 0, _ref = word.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        chr = word.charAt(i);
        if (node.next[chr]) {
          node = node.next[chr];
        } else {
          return null;
        }
      }
      return node;
    };

    Trie.prototype.print = function(prefix) {
      var i, out;
      out = this.value ? this.value : '(base)';
      if (this.is_word) {
        out = '[' + out + ']';
      }
      if (prefix) {
        out = prefix + out;
      }
      console.log(out);
      if (this.fail) {
        console.log([out, ' <- ', this.fail.value].join(''));
      }
      for (i in this.next) {
        this.next[i].print(out + ' -> ');
      }
      return this;
    };

    return Trie;

  })();

  AhoCorasick = (function() {

    function AhoCorasick() {
      this.trie = new Trie();
    }

    AhoCorasick.prototype.add = function(word, data) {
      return this.trie.add(word, data);
    };

    AhoCorasick.prototype.build_fail = function(node) {
      var fail_node, i, _i, _ref;
      node = node || this.trie;
      node.fail = null;
      if (node.value) {
        for (i = _i = 1, _ref = node.value.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
          fail_node = this.trie.explore_fail_link(node.value.substring(i));
          if (fail_node) {
            node.fail = fail_node;
            break;
          }
        }
      }
      for (i in node.next) {
        this.build_fail(node.next[i]);
      }
      return this;
    };

    AhoCorasick.prototype.foreach_match_do_callback = function(node, pos, callback) {
      var offset;
      while (node) {
        if (node.is_word) {
          offset = pos - node.value.length;
          callback(node.value, node.data, offset);
        }
        node = node.fail;
      }
      return this;
    };

    AhoCorasick.prototype.search = function(string, callback) {
      var chr, current, idx, _i, _ref;
      current = this.trie;
      for (idx = _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        chr = string.charAt(idx);
        while (current && !current.next[chr]) {
          current = current.fail;
        }
        if (current) {
          current = current.next[chr];
          if (callback) {
            this.foreach_match_do_callback(current, idx + 1, callback);
          }
        } else {
          current = this.trie;
        }
      }
      return this;
    };

    return AhoCorasick;

  })();

  if (module) {
    module.exports = AhoCorasick;
  } else {
    window.AhoCorasick = AhoCorasick;
  }

}).call(this);
