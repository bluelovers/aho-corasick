// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";

  var AhoCorasick, Trie;

  Trie = (function() {

    function Trie() {
      this.next = {};
      this.is_word = null;
      this.value = null;
      this.data = [];
    }

    Trie.prototype.add = function(word, data, original_word) {
      var chr, node;
      chr = word.charAt(0);
      node = this.next[chr];
      if (!node) {
        node = this.next[chr] = new Trie();
        if (original_word) {
          node.value = original_word.substr(0, original_word.length - word.length + 1);
        } else {
          node.value = chr;
        }
      }
      if (word.length > 1) {
        return node.add(word.substring(1), data, original_word || word);
      } else {
        node.data.push(data);
        return node.is_word = true;
      }
    };

    Trie.prototype.explore_fail_link = function(word) {
      var chr, i, node, _i, _ref;
      node = this;
      for (i = _i = 0, _ref = word.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        chr = word.charAt(i);
        node = node.next[chr];
        if (!node) {
          return null;
        }
      }
      return node;
    };

    Trie.prototype.foreach_edge = function(link_cb, fail_cb) {
      var each_node, sub_node, _k, _ref;
      each_node = function(from, node) {
        var sub_node, _k, _ref;
        link_cb(from, node);
        if (node.fail) {
          fail_cb(node, node.fail);
        }
        _ref = node.next;
        for (_k in _ref) {
          sub_node = _ref[_k];
          each_node(node, sub_node);
        }
        return this;
      };
      _ref = this.next;
      for (_k in _ref) {
        sub_node = _ref[_k];
        each_node('root', sub_node);
      }
      return this;
    };

    return Trie;

  })();

  AhoCorasick = (function() {

    function AhoCorasick() {
      this.trie = new Trie();
    }

    AhoCorasick.prototype.add = function(word, data) {
      return this.trie.add(word, data);
    };

    AhoCorasick.prototype.build_fail = function(node) {
      var fail_node, i, sub_node, _i, _k, _ref, _ref1;
      node = node || this.trie;
      node.fail = null;
      if (node.value) {
        for (i = _i = 1, _ref = node.value.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
          fail_node = this.trie.explore_fail_link(node.value.substring(i));
          if (fail_node) {
            node.fail = fail_node;
            break;
          }
        }
      }
      _ref1 = node.next;
      for (_k in _ref1) {
        sub_node = _ref1[_k];
        this.build_fail(sub_node);
      }
      return this;
    };

    AhoCorasick.prototype.foreach_match = function(node, pos, callback) {
      var offset;
      while (node) {
        if (node.is_word) {
          offset = pos - node.value.length;
          callback(node.value, node.data, offset);
        }
        node = node.fail;
      }
      return this;
    };

    AhoCorasick.prototype.search = function(string, callback) {
      var chr, current, idx, _i, _ref;
      current = this.trie;
      for (idx = _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        chr = string.charAt(idx);
        while (current && !current.next[chr]) {
          current = current.fail;
        }
        if (!current) {
          current = this.trie;
        }
        if (current.next[chr]) {
          current = current.next[chr];
          if (callback) {
            this.foreach_match(current, idx + 1, callback);
          }
        }
      }
      return this;
    };

    AhoCorasick.prototype.build_edge_png = function() {
      var fail_cb, g, graphviz, link_cb, util, val;
      util = require('util');
      graphviz = require('graphviz');
      g = graphviz.digraph("ac");
      val = function(node) {
        return node.value || node;
      };
      link_cb = function(from, to) {
        var k, option, v;
        g.addEdge(val(from), val(to));
        if (to.is_word) {
          option = {
            style: 'filled',
            color: 'skyblue'
          };
          for (k in option) {
            v = option[k];
            g.getNode(val(to)).set(k, v);
          }
        }
        return true;
      };
      fail_cb = function(from, to) {
        return g.addEdge(val(from), val(to), {
          style: 'dashed'
        });
      };
      this.trie.foreach_edge(link_cb, fail_cb);
      return g.output("png", "trie.png");
    };

    return AhoCorasick;

  })();

  if (module) {
    module.exports = AhoCorasick;
  } else {
    window.AhoCorasick = AhoCorasick;
  }

}).call(this);
